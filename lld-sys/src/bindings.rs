/* automatically generated by rust-bindgen 0.57.0 */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type size_t = ::std::os::raw::c_ulong;
pub type std_size_t = ::std::os::raw::c_ulong;
#[repr(C)]
pub struct std_basic_string<_CharT> {
    pub _M_dataplus: std_basic_string__Alloc_hider,
    pub _M_string_length: std_basic_string_size_type,
    pub __bindgen_anon_1: std_basic_string__bindgen_ty_2<_CharT>,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_basic_string__Char_alloc_type = __gnu_cxx___alloc_traits;
pub type std_basic_string__Alloc_traits = __gnu_cxx___alloc_traits;
pub type std_basic_string_traits_type<_Traits> = _Traits;
pub type std_basic_string_value_type = [u8; 0usize];
pub type std_basic_string_allocator_type = std_basic_string__Char_alloc_type;
pub type std_basic_string_size_type = std_basic_string__Alloc_traits;
pub type std_basic_string_difference_type = std_basic_string__Alloc_traits;
pub type std_basic_string_reference = std_basic_string__Alloc_traits;
pub type std_basic_string_const_reference = std_basic_string__Alloc_traits;
pub type std_basic_string_pointer = std_basic_string__Alloc_traits;
pub type std_basic_string_const_pointer = std_basic_string__Alloc_traits;
pub type std_basic_string_iterator = __gnu_cxx___normal_iterator<std_basic_string_pointer>;
pub type std_basic_string_const_iterator =
    __gnu_cxx___normal_iterator<std_basic_string_const_pointer>;
pub type std_basic_string_const_reverse_iterator =
    std_reverse_iterator<std_basic_string_const_iterator>;
pub type std_basic_string_reverse_iterator = std_reverse_iterator<std_basic_string_iterator>;
pub type std_basic_string___const_iterator = std_basic_string_const_iterator;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_basic_string__Alloc_hider {
    pub _M_p: std_basic_string_pointer,
}
pub const std_basic_string__S_local_capacity: i32 = 0;
pub type std_basic_string__bindgen_ty_1 = i32;
#[repr(C)]
pub union std_basic_string__bindgen_ty_2<_CharT> {
    pub _M_local_buf: *mut _CharT,
    pub _M_allocated_capacity: std_basic_string_size_type,
    _bindgen_union_align: u64,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_CharT>>,
}
pub type std_integral_constant_value_type<_Tp> = _Tp;
pub type std_integral_constant_type = u8;
pub type std_true_type = u8;
pub type std_false_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___and_ {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_is_empty {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_make_unsigned {
    pub _address: u8,
}
pub type std_make_unsigned_type = u8;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___detector {
    pub _address: u8,
}
pub type std___detector_value_t = std_false_type;
pub type std___detector_type<_Default> = _Default;
pub type std___detected_or = std___detector;
pub type std___detected_or_t = std___detected_or;
pub type std_string = std_basic_string<::std::os::raw::c_char>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator {
    pub _address: u8,
}
pub type std_iterator_iterator_category<_Category> = _Category;
pub type std_iterator_value_type<_Tp> = _Tp;
pub type std_iterator_difference_type<_Distance> = _Distance;
pub type std_iterator_pointer<_Pointer> = _Pointer;
pub type std_iterator_reference<_Reference> = _Reference;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_iterator_traits {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___undefined {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___get_first_arg {
    pub _address: u8,
}
pub type std___get_first_arg_type = std___undefined;
pub type std___get_first_arg_t = std___get_first_arg;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___replace_first_arg {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits {
    pub _address: u8,
}
pub type std_pointer_traits___element_type = [u8; 0usize];
pub type std_pointer_traits___difference_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_pointer_traits___rebind {
    pub _address: u8,
}
pub type std_pointer_traits_pointer<_Ptr> = _Ptr;
pub type std_pointer_traits_element_type = std___detected_or_t;
pub type std_pointer_traits_difference_type = std___detected_or_t;
pub type std_pointer_traits_rebind = std_pointer_traits___rebind;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_reverse_iterator<_Iterator> {
    pub current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type std_reverse_iterator___traits_type = std_iterator_traits;
pub type std_reverse_iterator_iterator_type<_Iterator> = _Iterator;
pub type std_reverse_iterator_difference_type = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_pointer = std_reverse_iterator___traits_type;
pub type std_reverse_iterator_reference = std_reverse_iterator___traits_type;
pub type std_streamoff = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug)]
pub struct std_fpos<_StateT> {
    pub _M_off: std_streamoff,
    pub _M_state: _StateT,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_StateT>>,
}
pub type std_streampos = std_fpos<mbstate_t>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_char_traits {
    pub _address: u8,
}
pub type std___allocator_base = __gnu_cxx_new_allocator;
#[repr(C)]
#[derive(Debug)]
pub struct std_allocator {
    pub _address: u8,
}
pub type std_allocator_size_type = std_size_t;
pub type std_allocator_difference_type = isize;
pub type std_allocator_pointer<_Tp> = *mut _Tp;
pub type std_allocator_const_pointer<_Tp> = *const _Tp;
pub type std_allocator_reference<_Tp> = *mut _Tp;
pub type std_allocator_const_reference<_Tp> = *const _Tp;
pub type std_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_rebind {
    pub _address: u8,
}
pub type std_allocator_rebind_other = std_allocator;
pub type std_allocator_propagate_on_container_move_assignment = std_true_type;
pub type std_allocator_is_always_equal = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std___allocator_traits_base___rebind {
    pub _address: u8,
}
pub type std___allocator_traits_base___pointer = [u8; 0usize];
pub type std___allocator_traits_base___c_pointer = [u8; 0usize];
pub type std___allocator_traits_base___v_pointer = [u8; 0usize];
pub type std___allocator_traits_base___cv_pointer = [u8; 0usize];
pub type std___allocator_traits_base___pocca = [u8; 0usize];
pub type std___allocator_traits_base___pocma = [u8; 0usize];
pub type std___allocator_traits_base___pocs = [u8; 0usize];
pub type std___allocator_traits_base___equal = [u8; 0usize];
#[test]
fn bindgen_test_layout_std___allocator_traits_base() {
    assert_eq!(
        ::std::mem::size_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Size of: ", stringify!(std___allocator_traits_base))
    );
    assert_eq!(
        ::std::mem::align_of::<std___allocator_traits_base>(),
        1usize,
        concat!("Alignment of ", stringify!(std___allocator_traits_base))
    );
}
pub type std___alloc_rebind = std___allocator_traits_base;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits {
    pub _address: u8,
}
pub type std_allocator_traits_allocator_type<_Alloc> = _Alloc;
pub type std_allocator_traits_value_type = [u8; 0usize];
pub type std_allocator_traits_pointer = std___detected_or_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Ptr {
    pub _address: u8,
}
pub type std_allocator_traits__Ptr_type = [u8; 0usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Diff {
    pub _address: u8,
}
pub type std_allocator_traits__Diff_type = std_pointer_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits__Size {
    pub _address: u8,
}
pub type std_allocator_traits_const_pointer = [u8; 0usize];
pub type std_allocator_traits_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_const_void_pointer = std_allocator_traits__Ptr;
pub type std_allocator_traits_difference_type = [u8; 0usize];
pub type std_allocator_traits_size_type = [u8; 0usize];
pub type std_allocator_traits_propagate_on_container_copy_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_move_assignment = std___detected_or_t;
pub type std_allocator_traits_propagate_on_container_swap = std___detected_or_t;
pub type std_allocator_traits_is_always_equal = std___detected_or_t;
pub type std_allocator_traits_rebind_alloc = std___alloc_rebind;
pub type std_allocator_traits_rebind_traits = std_allocator_traits;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_allocator_traits___construct_helper {
    pub _address: u8,
}
pub type std_allocator_traits___construct_helper_type<_Alloc> = _Alloc;
pub type std_allocator_traits___has_construct = std_allocator_traits___construct_helper;
#[repr(C)]
pub struct std_error_category__bindgen_vtable(::std::os::raw::c_void);
#[repr(C)]
#[derive(Debug)]
pub struct std_error_category {
    pub vtable_: *const std_error_category__bindgen_vtable,
}
#[test]
fn bindgen_test_layout_std_error_category() {
    assert_eq!(
        ::std::mem::size_of::<std_error_category>(),
        8usize,
        concat!("Size of: ", stringify!(std_error_category))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_category>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_category))
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNSt3_V214error_categoryD1Ev"]
    pub fn std_error_category_error_category_destructor(this: *mut std_error_category);
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category23default_error_conditionEi"]
    pub fn std_error_category_default_error_condition(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
    ) -> std_error_condition;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentEiRKSt15error_condition"]
    pub fn std_error_category_equivalent(
        this: *mut ::std::os::raw::c_void,
        __i: ::std::os::raw::c_int,
        __cond: *const std_error_condition,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt3_V214error_category10equivalentERKSt10error_codei"]
    pub fn std_error_category_equivalent1(
        this: *mut ::std::os::raw::c_void,
        __code: *const std_error_code,
        __i: ::std::os::raw::c_int,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_code {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std_error_category,
}
#[test]
fn bindgen_test_layout_std_error_code() {
    assert_eq!(
        ::std::mem::size_of::<std_error_code>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_code))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_code>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_code))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_error_code>()))._M_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_code),
            "::",
            stringify!(_M_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_error_code>()))._M_cat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_code),
            "::",
            stringify!(_M_cat)
        )
    );
}
extern "C" {
    #[link_name = "\u{1}_ZNKSt10error_code23default_error_conditionEv"]
    pub fn std_error_code_default_error_condition(
        this: *const std_error_code,
    ) -> std_error_condition;
}
impl std_error_code {
    #[inline]
    pub unsafe fn default_error_condition(&self) -> std_error_condition {
        std_error_code_default_error_condition(self)
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct std_error_condition {
    pub _M_value: ::std::os::raw::c_int,
    pub _M_cat: *const std_error_category,
}
#[test]
fn bindgen_test_layout_std_error_condition() {
    assert_eq!(
        ::std::mem::size_of::<std_error_condition>(),
        16usize,
        concat!("Size of: ", stringify!(std_error_condition))
    );
    assert_eq!(
        ::std::mem::align_of::<std_error_condition>(),
        8usize,
        concat!("Alignment of ", stringify!(std_error_condition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_error_condition>()))._M_value as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_condition),
            "::",
            stringify!(_M_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<std_error_condition>()))._M_cat as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(std_error_condition),
            "::",
            stringify!(_M_cat)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___normal_iterator<_Iterator> {
    pub _M_current: _Iterator,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<_Iterator>>,
}
pub type __gnu_cxx___normal_iterator___traits_type = std_iterator_traits;
pub type __gnu_cxx___normal_iterator_iterator_type<_Iterator> = _Iterator;
pub type __gnu_cxx___normal_iterator_iterator_category = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_value_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_difference_type = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_reference = __gnu_cxx___normal_iterator___traits_type;
pub type __gnu_cxx___normal_iterator_pointer = __gnu_cxx___normal_iterator___traits_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx__Char_types {
    pub _address: u8,
}
pub type __gnu_cxx__Char_types_int_type = ::std::os::raw::c_ulong;
pub type __gnu_cxx__Char_types_pos_type = std_streampos;
pub type __gnu_cxx__Char_types_off_type = std_streamoff;
pub type __gnu_cxx__Char_types_state_type = mbstate_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_char_traits {
    pub _address: u8,
}
pub type __gnu_cxx_char_traits_char_type<_CharT> = _CharT;
pub type __gnu_cxx_char_traits_int_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_pos_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_off_type = __gnu_cxx__Char_types;
pub type __gnu_cxx_char_traits_state_type = __gnu_cxx__Char_types;
#[repr(C)]
#[derive(Debug)]
pub struct __gnu_cxx_new_allocator {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_size_type = std_size_t;
pub type __gnu_cxx_new_allocator_difference_type = isize;
pub type __gnu_cxx_new_allocator_pointer<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_pointer<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_reference<_Tp> = *mut _Tp;
pub type __gnu_cxx_new_allocator_const_reference<_Tp> = *const _Tp;
pub type __gnu_cxx_new_allocator_value_type<_Tp> = _Tp;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx_new_allocator_rebind {
    pub _address: u8,
}
pub type __gnu_cxx_new_allocator_rebind_other = __gnu_cxx_new_allocator;
pub type __gnu_cxx_new_allocator_propagate_on_container_move_assignment = std_true_type;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_allocator_type<_Alloc> = _Alloc;
pub type __gnu_cxx___alloc_traits__Base_type = std_allocator_traits;
pub type __gnu_cxx___alloc_traits_value_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_const_pointer = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_size_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_difference_type = __gnu_cxx___alloc_traits__Base_type;
pub type __gnu_cxx___alloc_traits_reference = *mut __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits_const_reference = *const __gnu_cxx___alloc_traits_value_type;
pub type __gnu_cxx___alloc_traits___is_custom_pointer = std___and_;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __gnu_cxx___alloc_traits_rebind {
    pub _address: u8,
}
pub type __gnu_cxx___alloc_traits_rebind_other = __gnu_cxx___alloc_traits__Base_type;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type llvm_sys_fs_FileAccess = ::std::os::raw::c_uint;
pub type llvm_sys_fs_OpenFlags = ::std::os::raw::c_uint;
pub type llvm_sys_fs_CreationDisposition = ::std::os::raw::c_uint;
#[doc = " This class consists of common code factored out of the SmallVector class to"]
#[doc = " reduce code duplication based on the SmallVector 'N' template parameter."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_SmallVectorImpl {
    pub _address: u8,
}
pub type llvm_SmallVectorImpl_SuperClass = u8;
pub type llvm_SmallVectorImpl_iterator = llvm_SmallVectorImpl_SuperClass;
pub type llvm_SmallVectorImpl_const_iterator = llvm_SmallVectorImpl_SuperClass;
pub type llvm_SmallVectorImpl_reference = llvm_SmallVectorImpl_SuperClass;
pub type llvm_SmallVectorImpl_size_type = llvm_SmallVectorImpl_SuperClass;
#[doc = " ArrayRef - Represent a constant reference to an array (0 or more elements"]
#[doc = " consecutively in memory), i.e. a start pointer and a length.  It allows"]
#[doc = " various APIs to take consecutive elements easily and conveniently."]
#[doc = ""]
#[doc = " This class does not own the underlying data, it is expected to be used in"]
#[doc = " situations where the data resides in some other buffer, whose lifetime"]
#[doc = " extends past that of the ArrayRef. For this reason, it is not in general"]
#[doc = " safe to store an ArrayRef."]
#[doc = ""]
#[doc = " This is intended to be trivially copyable, so it should be passed by"]
#[doc = " value."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_ArrayRef<T> {
    #[doc = " The start of the array, in an external buffer."]
    pub Data: *const T,
    #[doc = " The number of elements."]
    pub Length: llvm_ArrayRef_size_type,
    pub _phantom_0: ::std::marker::PhantomData<::std::cell::UnsafeCell<T>>,
}
pub type llvm_ArrayRef_iterator<T> = *const T;
pub type llvm_ArrayRef_const_iterator<T> = *const T;
pub type llvm_ArrayRef_size_type = size_t;
pub type llvm_ArrayRef_reverse_iterator<T> = std_reverse_iterator<llvm_ArrayRef_iterator<T>>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_APInt {
    _unused: [u8; 0],
}
#[doc = " StringRef - Represent a constant reference to a string, i.e. a character"]
#[doc = " array and a length, which need not be null terminated."]
#[doc = ""]
#[doc = " This class does not own the string data, it is expected to be used in"]
#[doc = " situations where the character data resides in some other buffer, whose"]
#[doc = " lifetime extends past that of the StringRef. For this reason, it is not in"]
#[doc = " general safe to store a StringRef."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct llvm_StringRef {
    #[doc = " The start of the string, in an external buffer."]
    pub Data: *const ::std::os::raw::c_char,
    #[doc = " The length of the string."]
    pub Length: size_t,
}
pub type llvm_StringRef_iterator = *const ::std::os::raw::c_char;
pub type llvm_StringRef_const_iterator = *const ::std::os::raw::c_char;
pub type llvm_StringRef_size_type = size_t;
extern "C" {
    #[link_name = "\u{1}_ZN4llvm9StringRef4nposE"]
    pub static llvm_StringRef_npos: size_t;
}
#[test]
fn bindgen_test_layout_llvm_StringRef() {
    assert_eq!(
        ::std::mem::size_of::<llvm_StringRef>(),
        16usize,
        concat!("Size of: ", stringify!(llvm_StringRef))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_StringRef>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_StringRef))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_StringRef>())).Data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringRef),
            "::",
            stringify!(Data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_StringRef>())).Length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_StringRef),
            "::",
            stringify!(Length)
        )
    );
}
extern "C" {
    #[doc = " compare_lower - Compare two strings, ignoring case."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef13compare_lowerES0_"]
    pub fn llvm_StringRef_compare_lower(
        this: *const llvm_StringRef,
        RHS: llvm_StringRef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " compare_numeric - Compare two strings, treating sequences of digits as"]
    #[doc = " numbers."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef15compare_numericES0_"]
    pub fn llvm_StringRef_compare_numeric(
        this: *const llvm_StringRef,
        RHS: llvm_StringRef,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Determine the edit distance between this string and another"]
    #[doc = " string."]
    #[doc = ""]
    #[doc = " \\param Other the string to compare this string against."]
    #[doc = ""]
    #[doc = " \\param AllowReplacements whether to allow character"]
    #[doc = " replacements (change one character into another) as a single"]
    #[doc = " operation, rather than as two operations (an insertion and a"]
    #[doc = " removal)."]
    #[doc = ""]
    #[doc = " \\param MaxEditDistance If non-zero, the maximum edit distance that"]
    #[doc = " this routine is allowed to compute. If the edit distance will exceed"]
    #[doc = " that maximum, returns \\c MaxEditDistance+1."]
    #[doc = ""]
    #[doc = " \\returns the minimum number of character insertions, removals,"]
    #[doc = " or (if \\p AllowReplacements is \\c true) replacements needed to"]
    #[doc = " transform one of the given strings into the other. If zero,"]
    #[doc = " the strings are identical."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef13edit_distanceES0_bj"]
    pub fn llvm_StringRef_edit_distance(
        this: *const llvm_StringRef,
        Other: llvm_StringRef,
        AllowReplacements: bool,
        MaxEditDistance: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " Check if this string starts with the given \\p Prefix, ignoring case."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef16startswith_lowerES0_"]
    pub fn llvm_StringRef_startswith_lower(
        this: *const llvm_StringRef,
        Prefix: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Check if this string ends with the given \\p Suffix, ignoring case."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef14endswith_lowerES0_"]
    pub fn llvm_StringRef_endswith_lower(
        this: *const llvm_StringRef,
        Suffix: llvm_StringRef,
    ) -> bool;
}
extern "C" {
    #[doc = " Search for the first character \\p C in the string, ignoring case."]
    #[doc = ""]
    #[doc = " \\returns The index of the first occurrence of \\p C, or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef10find_lowerEcm"]
    pub fn llvm_StringRef_find_lower(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Search for the first string \\p Str in the string."]
    #[doc = ""]
    #[doc = " \\returns The index of the first occurrence of \\p Str, or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef4findES0_m"]
    pub fn llvm_StringRef_find(
        this: *const llvm_StringRef,
        Str: llvm_StringRef,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Search for the first string \\p Str in the string, ignoring case."]
    #[doc = ""]
    #[doc = " \\returns The index of the first occurrence of \\p Str, or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef10find_lowerES0_m"]
    pub fn llvm_StringRef_find_lower1(
        this: *const llvm_StringRef,
        Str: llvm_StringRef,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Search for the last character \\p C in the string, ignoring case."]
    #[doc = ""]
    #[doc = " \\returns The index of the last occurrence of \\p C, or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef11rfind_lowerEcm"]
    pub fn llvm_StringRef_rfind_lower(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Search for the last string \\p Str in the string."]
    #[doc = ""]
    #[doc = " \\returns The index of the last occurrence of \\p Str, or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5rfindES0_"]
    pub fn llvm_StringRef_rfind(this: *const llvm_StringRef, Str: llvm_StringRef) -> size_t;
}
extern "C" {
    #[doc = " Search for the last string \\p Str in the string, ignoring case."]
    #[doc = ""]
    #[doc = " \\returns The index of the last occurrence of \\p Str, or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef11rfind_lowerES0_"]
    pub fn llvm_StringRef_rfind_lower1(this: *const llvm_StringRef, Str: llvm_StringRef) -> size_t;
}
extern "C" {
    #[doc = " Find the first character in the string that is in \\p Chars, or npos if"]
    #[doc = " not found."]
    #[doc = ""]
    #[doc = " Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef13find_first_ofES0_m"]
    pub fn llvm_StringRef_find_first_of(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Find the first character in the string that is not \\p C or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef17find_first_not_ofEcm"]
    pub fn llvm_StringRef_find_first_not_of(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Find the first character in the string that is not in the string"]
    #[doc = " \\p Chars, or npos if not found."]
    #[doc = ""]
    #[doc = " Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef17find_first_not_ofES0_m"]
    pub fn llvm_StringRef_find_first_not_of1(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Find the last character in the string that is in \\p C, or npos if not"]
    #[doc = " found."]
    #[doc = ""]
    #[doc = " Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef12find_last_ofES0_m"]
    pub fn llvm_StringRef_find_last_of(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Find the last character in the string that is not \\p C, or npos if not"]
    #[doc = " found."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef16find_last_not_ofEcm"]
    pub fn llvm_StringRef_find_last_not_of(
        this: *const llvm_StringRef,
        C: ::std::os::raw::c_char,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Find the last character in the string that is not in \\p Chars, or"]
    #[doc = " npos if not found."]
    #[doc = ""]
    #[doc = " Complexity: O(size() + Chars.size())"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef16find_last_not_ofES0_m"]
    pub fn llvm_StringRef_find_last_not_of1(
        this: *const llvm_StringRef,
        Chars: llvm_StringRef,
        From: size_t,
    ) -> size_t;
}
extern "C" {
    #[doc = " Return the number of non-overlapped occurrences of \\p Str in"]
    #[doc = " the string."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5countES0_"]
    pub fn llvm_StringRef_count(this: *const llvm_StringRef, Str: llvm_StringRef) -> size_t;
}
extern "C" {
    #[doc = " Parse the current string as an integer of the specified \\p Radix, or of"]
    #[doc = " an autosensed radix if the \\p Radix given is 0.  The current value in"]
    #[doc = " \\p Result is discarded, and the storage is changed to be wide enough to"]
    #[doc = " store the parsed integer."]
    #[doc = ""]
    #[doc = " \\returns true if the string does not solely consist of a valid"]
    #[doc = " non-empty number in the appropriate base."]
    #[doc = ""]
    #[doc = " APInt::fromString is superficially similar but assumes the"]
    #[doc = " string is well-formed in the given radix."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef12getAsIntegerEjRNS_5APIntE"]
    pub fn llvm_StringRef_getAsInteger(
        this: *const llvm_StringRef,
        Radix: ::std::os::raw::c_uint,
        Result: *mut llvm_APInt,
    ) -> bool;
}
extern "C" {
    #[doc = " Parse the current string as an IEEE double-precision floating"]
    #[doc = " point value.  The string must be a well-formed double."]
    #[doc = ""]
    #[doc = " If \\p AllowInexact is false, the function will fail if the string"]
    #[doc = " cannot be represented exactly.  Otherwise, the function only fails"]
    #[doc = " in case of an overflow or underflow, or an invalid floating point"]
    #[doc = " representation."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef11getAsDoubleERdb"]
    pub fn llvm_StringRef_getAsDouble(
        this: *const llvm_StringRef,
        Result: *mut f64,
        AllowInexact: bool,
    ) -> bool;
}
extern "C" {
    #[doc = " @}"]
    #[doc = " @name String Operations"]
    #[doc = " @{"]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5lowerB5cxx11Ev"]
    pub fn llvm_StringRef_lower(this: *const llvm_StringRef) -> std_string;
}
extern "C" {
    #[doc = " Convert the given ASCII string to uppercase."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5upperB5cxx11Ev"]
    pub fn llvm_StringRef_upper(this: *const llvm_StringRef) -> std_string;
}
extern "C" {
    #[doc = " Split into substrings around the occurrences of a separator string."]
    #[doc = ""]
    #[doc = " Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most"]
    #[doc = " \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1"]
    #[doc = " elements are added to A."]
    #[doc = " If \\p KeepEmpty is false, empty strings are not added to \\p A. They"]
    #[doc = " still count when considering \\p MaxSplit"]
    #[doc = " An useful invariant is that"]
    #[doc = " Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true"]
    #[doc = ""]
    #[doc = " \\param A - Where to put the substrings."]
    #[doc = " \\param Separator - The string to split on."]
    #[doc = " \\param MaxSplit - The maximum number of times the string is split."]
    #[doc = " \\param KeepEmpty - True if empty substring should be added."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5splitERNS_15SmallVectorImplIS0_EES0_ib"]
    pub fn llvm_StringRef_split(
        this: *const llvm_StringRef,
        A: *mut llvm_SmallVectorImpl,
        Separator: llvm_StringRef,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    );
}
extern "C" {
    #[doc = " Split into substrings around the occurrences of a separator character."]
    #[doc = ""]
    #[doc = " Each substring is stored in \\p A. If \\p MaxSplit is >= 0, at most"]
    #[doc = " \\p MaxSplit splits are done and consequently <= \\p MaxSplit + 1"]
    #[doc = " elements are added to A."]
    #[doc = " If \\p KeepEmpty is false, empty strings are not added to \\p A. They"]
    #[doc = " still count when considering \\p MaxSplit"]
    #[doc = " An useful invariant is that"]
    #[doc = " Separator.join(A) == *this if MaxSplit == -1 and KeepEmpty == true"]
    #[doc = ""]
    #[doc = " \\param A - Where to put the substrings."]
    #[doc = " \\param Separator - The string to split on."]
    #[doc = " \\param MaxSplit - The maximum number of times the string is split."]
    #[doc = " \\param KeepEmpty - True if empty substring should be added."]
    #[link_name = "\u{1}_ZNK4llvm9StringRef5splitERNS_15SmallVectorImplIS0_EEcib"]
    pub fn llvm_StringRef_split1(
        this: *const llvm_StringRef,
        A: *mut llvm_SmallVectorImpl,
        Separator: ::std::os::raw::c_char,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    );
}
impl llvm_StringRef {
    #[inline]
    pub unsafe fn compare_lower(&self, RHS: llvm_StringRef) -> ::std::os::raw::c_int {
        llvm_StringRef_compare_lower(self, RHS)
    }
    #[inline]
    pub unsafe fn compare_numeric(&self, RHS: llvm_StringRef) -> ::std::os::raw::c_int {
        llvm_StringRef_compare_numeric(self, RHS)
    }
    #[inline]
    pub unsafe fn edit_distance(
        &self,
        Other: llvm_StringRef,
        AllowReplacements: bool,
        MaxEditDistance: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint {
        llvm_StringRef_edit_distance(self, Other, AllowReplacements, MaxEditDistance)
    }
    #[inline]
    pub unsafe fn startswith_lower(&self, Prefix: llvm_StringRef) -> bool {
        llvm_StringRef_startswith_lower(self, Prefix)
    }
    #[inline]
    pub unsafe fn endswith_lower(&self, Suffix: llvm_StringRef) -> bool {
        llvm_StringRef_endswith_lower(self, Suffix)
    }
    #[inline]
    pub unsafe fn find_lower(&self, C: ::std::os::raw::c_char, From: size_t) -> size_t {
        llvm_StringRef_find_lower(self, C, From)
    }
    #[inline]
    pub unsafe fn find(&self, Str: llvm_StringRef, From: size_t) -> size_t {
        llvm_StringRef_find(self, Str, From)
    }
    #[inline]
    pub unsafe fn find_lower1(&self, Str: llvm_StringRef, From: size_t) -> size_t {
        llvm_StringRef_find_lower1(self, Str, From)
    }
    #[inline]
    pub unsafe fn rfind_lower(&self, C: ::std::os::raw::c_char, From: size_t) -> size_t {
        llvm_StringRef_rfind_lower(self, C, From)
    }
    #[inline]
    pub unsafe fn rfind(&self, Str: llvm_StringRef) -> size_t {
        llvm_StringRef_rfind(self, Str)
    }
    #[inline]
    pub unsafe fn rfind_lower1(&self, Str: llvm_StringRef) -> size_t {
        llvm_StringRef_rfind_lower1(self, Str)
    }
    #[inline]
    pub unsafe fn find_first_of(&self, Chars: llvm_StringRef, From: size_t) -> size_t {
        llvm_StringRef_find_first_of(self, Chars, From)
    }
    #[inline]
    pub unsafe fn find_first_not_of(&self, C: ::std::os::raw::c_char, From: size_t) -> size_t {
        llvm_StringRef_find_first_not_of(self, C, From)
    }
    #[inline]
    pub unsafe fn find_first_not_of1(&self, Chars: llvm_StringRef, From: size_t) -> size_t {
        llvm_StringRef_find_first_not_of1(self, Chars, From)
    }
    #[inline]
    pub unsafe fn find_last_of(&self, Chars: llvm_StringRef, From: size_t) -> size_t {
        llvm_StringRef_find_last_of(self, Chars, From)
    }
    #[inline]
    pub unsafe fn find_last_not_of(&self, C: ::std::os::raw::c_char, From: size_t) -> size_t {
        llvm_StringRef_find_last_not_of(self, C, From)
    }
    #[inline]
    pub unsafe fn find_last_not_of1(&self, Chars: llvm_StringRef, From: size_t) -> size_t {
        llvm_StringRef_find_last_not_of1(self, Chars, From)
    }
    #[inline]
    pub unsafe fn count(&self, Str: llvm_StringRef) -> size_t {
        llvm_StringRef_count(self, Str)
    }
    #[inline]
    pub unsafe fn getAsInteger(
        &self,
        Radix: ::std::os::raw::c_uint,
        Result: *mut llvm_APInt,
    ) -> bool {
        llvm_StringRef_getAsInteger(self, Radix, Result)
    }
    #[inline]
    pub unsafe fn getAsDouble(&self, Result: *mut f64, AllowInexact: bool) -> bool {
        llvm_StringRef_getAsDouble(self, Result, AllowInexact)
    }
    #[inline]
    pub unsafe fn lower(&self) -> std_string {
        llvm_StringRef_lower(self)
    }
    #[inline]
    pub unsafe fn upper(&self) -> std_string {
        llvm_StringRef_upper(self)
    }
    #[inline]
    pub unsafe fn split(
        &self,
        A: *mut llvm_SmallVectorImpl,
        Separator: llvm_StringRef,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    ) {
        llvm_StringRef_split(self, A, Separator, MaxSplit, KeepEmpty)
    }
    #[inline]
    pub unsafe fn split1(
        &self,
        A: *mut llvm_SmallVectorImpl,
        Separator: ::std::os::raw::c_char,
        MaxSplit: ::std::os::raw::c_int,
        KeepEmpty: bool,
    ) {
        llvm_StringRef_split1(self, A, Separator, MaxSplit, KeepEmpty)
    }
}
#[repr(C)]
pub struct llvm_raw_ostream__bindgen_vtable(::std::os::raw::c_void);
#[doc = " This class implements an extremely fast bulk output stream that can *only*"]
#[doc = " output to a stream.  It does not support seeking, reopening, rewinding, line"]
#[doc = " buffered disciplines etc. It is a simple buffer that outputs"]
#[doc = " a chunk at a time."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_ostream {
    pub vtable_: *const llvm_raw_ostream__bindgen_vtable,
    #[doc = " The buffer is handled in such a way that the buffer is"]
    #[doc = " uninitialized, unbuffered, or out of space when OutBufCur >="]
    #[doc = " OutBufEnd. Thus a single comparison suffices to determine if we"]
    #[doc = " need to take the slow path to write a single character."]
    #[doc = ""]
    #[doc = " The buffer is in one of three states:"]
    #[doc = "  1. Unbuffered (BufferMode == Unbuffered)"]
    #[doc = "  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0)."]
    #[doc = "  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&"]
    #[doc = "               OutBufEnd - OutBufStart >= 1)."]
    #[doc = ""]
    #[doc = " If buffered, then the raw_ostream owns the buffer if (BufferMode =="]
    #[doc = " InternalBuffer); otherwise the buffer has been set via SetBuffer and is"]
    #[doc = " managed by the subclass."]
    #[doc = ""]
    #[doc = " If a subclass installs an external buffer using SetBuffer then it can wait"]
    #[doc = " for a \\see write_impl() call to handle the data which has been put into"]
    #[doc = " this buffer."]
    pub OutBufStart: *mut ::std::os::raw::c_char,
    #[doc = " The buffer is handled in such a way that the buffer is"]
    #[doc = " uninitialized, unbuffered, or out of space when OutBufCur >="]
    #[doc = " OutBufEnd. Thus a single comparison suffices to determine if we"]
    #[doc = " need to take the slow path to write a single character."]
    #[doc = ""]
    #[doc = " The buffer is in one of three states:"]
    #[doc = "  1. Unbuffered (BufferMode == Unbuffered)"]
    #[doc = "  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0)."]
    #[doc = "  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&"]
    #[doc = "               OutBufEnd - OutBufStart >= 1)."]
    #[doc = ""]
    #[doc = " If buffered, then the raw_ostream owns the buffer if (BufferMode =="]
    #[doc = " InternalBuffer); otherwise the buffer has been set via SetBuffer and is"]
    #[doc = " managed by the subclass."]
    #[doc = ""]
    #[doc = " If a subclass installs an external buffer using SetBuffer then it can wait"]
    #[doc = " for a \\see write_impl() call to handle the data which has been put into"]
    #[doc = " this buffer."]
    pub OutBufEnd: *mut ::std::os::raw::c_char,
    #[doc = " The buffer is handled in such a way that the buffer is"]
    #[doc = " uninitialized, unbuffered, or out of space when OutBufCur >="]
    #[doc = " OutBufEnd. Thus a single comparison suffices to determine if we"]
    #[doc = " need to take the slow path to write a single character."]
    #[doc = ""]
    #[doc = " The buffer is in one of three states:"]
    #[doc = "  1. Unbuffered (BufferMode == Unbuffered)"]
    #[doc = "  1. Uninitialized (BufferMode != Unbuffered && OutBufStart == 0)."]
    #[doc = "  2. Buffered (BufferMode != Unbuffered && OutBufStart != 0 &&"]
    #[doc = "               OutBufEnd - OutBufStart >= 1)."]
    #[doc = ""]
    #[doc = " If buffered, then the raw_ostream owns the buffer if (BufferMode =="]
    #[doc = " InternalBuffer); otherwise the buffer has been set via SetBuffer and is"]
    #[doc = " managed by the subclass."]
    #[doc = ""]
    #[doc = " If a subclass installs an external buffer using SetBuffer then it can wait"]
    #[doc = " for a \\see write_impl() call to handle the data which has been put into"]
    #[doc = " this buffer."]
    pub OutBufCur: *mut ::std::os::raw::c_char,
    pub ColorEnabled: bool,
    #[doc = " Optional stream this stream is tied to. If this stream is written to, the"]
    #[doc = " tied-to stream will be flushed first."]
    pub TiedStream: *mut llvm_raw_ostream,
    pub BufferMode: llvm_raw_ostream_BufferKind,
}
pub const llvm_raw_ostream_BufferKind_Unbuffered: llvm_raw_ostream_BufferKind = 0;
pub const llvm_raw_ostream_BufferKind_InternalBuffer: llvm_raw_ostream_BufferKind = 1;
pub const llvm_raw_ostream_BufferKind_ExternalBuffer: llvm_raw_ostream_BufferKind = 2;
pub type llvm_raw_ostream_BufferKind = ::std::os::raw::c_int;
pub const llvm_raw_ostream_Colors_BLACK: llvm_raw_ostream_Colors = 0;
pub const llvm_raw_ostream_Colors_RED: llvm_raw_ostream_Colors = 1;
pub const llvm_raw_ostream_Colors_GREEN: llvm_raw_ostream_Colors = 2;
pub const llvm_raw_ostream_Colors_YELLOW: llvm_raw_ostream_Colors = 3;
pub const llvm_raw_ostream_Colors_BLUE: llvm_raw_ostream_Colors = 4;
pub const llvm_raw_ostream_Colors_MAGENTA: llvm_raw_ostream_Colors = 5;
pub const llvm_raw_ostream_Colors_CYAN: llvm_raw_ostream_Colors = 6;
pub const llvm_raw_ostream_Colors_WHITE: llvm_raw_ostream_Colors = 7;
pub const llvm_raw_ostream_Colors_SAVEDCOLOR: llvm_raw_ostream_Colors = 8;
pub const llvm_raw_ostream_Colors_RESET: llvm_raw_ostream_Colors = 9;
pub type llvm_raw_ostream_Colors = ::std::os::raw::c_int;
#[doc = " Output a formatted UUID with dash separators."]
pub type llvm_raw_ostream_uuid_t = [u8; 16usize];
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5BLACKE"]
    pub static llvm_raw_ostream_BLACK: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream3REDE"]
    pub static llvm_raw_ostream_RED: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5GREENE"]
    pub static llvm_raw_ostream_GREEN: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream6YELLOWE"]
    pub static llvm_raw_ostream_YELLOW: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream4BLUEE"]
    pub static llvm_raw_ostream_BLUE: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream7MAGENTAE"]
    pub static llvm_raw_ostream_MAGENTA: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream4CYANE"]
    pub static llvm_raw_ostream_CYAN: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5WHITEE"]
    pub static llvm_raw_ostream_WHITE: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream10SAVEDCOLORE"]
    pub static llvm_raw_ostream_SAVEDCOLOR: llvm_raw_ostream_Colors;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5RESETE"]
    pub static llvm_raw_ostream_RESET: llvm_raw_ostream_Colors;
}
#[test]
fn bindgen_test_layout_llvm_raw_ostream() {
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_ostream>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_raw_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_ostream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_ostream>())).OutBufStart as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(OutBufStart)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_ostream>())).OutBufEnd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(OutBufEnd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_ostream>())).OutBufCur as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(OutBufCur)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_ostream>())).ColorEnabled as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(ColorEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_ostream>())).TiedStream as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(TiedStream)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_ostream>())).BufferMode as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_ostream),
            "::",
            stringify!(BufferMode)
        )
    );
}
extern "C" {
    #[doc = " Set the stream to be buffered, with an automatically determined buffer"]
    #[doc = " size."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11SetBufferedEv"]
    pub fn llvm_raw_ostream_SetBuffered(this: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Output \\p N in hexadecimal, without any prefix or padding."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream9write_hexEy"]
    pub fn llvm_raw_ostream_write_hex(
        this: *mut llvm_raw_ostream,
        N: ::std::os::raw::c_ulonglong,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream10write_uuidEPKh"]
    pub fn llvm_raw_ostream_write_uuid(
        this: *mut llvm_raw_ostream,
        UUID: *mut u8,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Output \\p Str, turning '\\\\', '\\t', '\\n', '\"', and anything that doesn't"]
    #[doc = " satisfy llvm::isPrint into an escape sequence."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream13write_escapedENS_9StringRefEb"]
    pub fn llvm_raw_ostream_write_escaped(
        this: *mut llvm_raw_ostream,
        Str: llvm_StringRef,
        UseHexEscapes: bool,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5writeEh"]
    pub fn llvm_raw_ostream_write(
        this: *mut llvm_raw_ostream,
        C: ::std::os::raw::c_uchar,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostream5writeEPKcm"]
    pub fn llvm_raw_ostream_write1(
        this: *mut llvm_raw_ostream,
        Ptr: *const ::std::os::raw::c_char,
        Size: size_t,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " indent - Insert 'NumSpaces' spaces."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream6indentEj"]
    pub fn llvm_raw_ostream_indent(
        this: *mut llvm_raw_ostream,
        NumSpaces: ::std::os::raw::c_uint,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " write_zeros - Insert 'NumZeros' nulls."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11write_zerosEj"]
    pub fn llvm_raw_ostream_write_zeros(
        this: *mut llvm_raw_ostream,
        NumZeros: ::std::os::raw::c_uint,
    ) -> *mut llvm_raw_ostream;
}
impl llvm_raw_ostream {
    #[inline]
    pub unsafe fn SetBuffered(&mut self) {
        llvm_raw_ostream_SetBuffered(self)
    }
    #[inline]
    pub unsafe fn write_hex(&mut self, N: ::std::os::raw::c_ulonglong) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_hex(self, N)
    }
    #[inline]
    pub unsafe fn write_uuid(&mut self, UUID: *mut u8) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_uuid(self, UUID)
    }
    #[inline]
    pub unsafe fn write_escaped(
        &mut self,
        Str: llvm_StringRef,
        UseHexEscapes: bool,
    ) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_escaped(self, Str, UseHexEscapes)
    }
    #[inline]
    pub unsafe fn write(&mut self, C: ::std::os::raw::c_uchar) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write(self, C)
    }
    #[inline]
    pub unsafe fn write1(
        &mut self,
        Ptr: *const ::std::os::raw::c_char,
        Size: size_t,
    ) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write1(self, Ptr, Size)
    }
    #[inline]
    pub unsafe fn indent(&mut self, NumSpaces: ::std::os::raw::c_uint) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_indent(self, NumSpaces)
    }
    #[inline]
    pub unsafe fn write_zeros(
        &mut self,
        NumZeros: ::std::os::raw::c_uint,
    ) -> *mut llvm_raw_ostream {
        llvm_raw_ostream_write_zeros(self, NumZeros)
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm11raw_ostreamD1Ev"]
    pub fn llvm_raw_ostream_raw_ostream_destructor(this: *mut llvm_raw_ostream);
}
extern "C" {
    #[doc = " Changes the foreground color of text that will be output from this point"]
    #[doc = " forward."]
    #[doc = " @param Color ANSI color to use, the special SAVEDCOLOR can be used to"]
    #[doc = " change only the bold attribute, and keep colors untouched"]
    #[doc = " @param Bold bold/brighter text, default false"]
    #[doc = " @param BG if true change the background, default: change foreground"]
    #[doc = " @returns itself so it can be used within << invocations"]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream11changeColorENS0_6ColorsEbb"]
    pub fn llvm_raw_ostream_changeColor(
        this: *mut ::std::os::raw::c_void,
        Color: llvm_raw_ostream_Colors,
        Bold: bool,
        BG: bool,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Resets the colors to terminal defaults. Call this when you are done"]
    #[doc = " outputting colored text, or before program exit."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream10resetColorEv"]
    pub fn llvm_raw_ostream_resetColor(this: *mut ::std::os::raw::c_void) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Reverses the foreground and background colors."]
    #[link_name = "\u{1}_ZN4llvm11raw_ostream12reverseColorEv"]
    pub fn llvm_raw_ostream_reverseColor(
        this: *mut ::std::os::raw::c_void,
    ) -> *mut llvm_raw_ostream;
}
extern "C" {
    #[doc = " Return an efficient buffer size for the underlying output mechanism."]
    #[link_name = "\u{1}_ZNK4llvm11raw_ostream21preferred_buffer_sizeEv"]
    pub fn llvm_raw_ostream_preferred_buffer_size(this: *mut ::std::os::raw::c_void) -> size_t;
}
#[doc = " An abstract base class for streams implementations that also support a"]
#[doc = " pwrite operation. This is useful for code that can mostly stream out data,"]
#[doc = " but needs to patch in a header that needs to know the output size."]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_pwrite_stream {
    pub _base: llvm_raw_ostream,
}
#[test]
fn bindgen_test_layout_llvm_raw_pwrite_stream() {
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_pwrite_stream>(),
        56usize,
        concat!("Size of: ", stringify!(llvm_raw_pwrite_stream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_pwrite_stream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_pwrite_stream))
    );
}
#[doc = " A raw_ostream that writes to a file descriptor."]
#[doc = ""]
#[repr(C)]
#[derive(Debug)]
pub struct llvm_raw_fd_ostream {
    pub _base: llvm_raw_pwrite_stream,
    pub FD: ::std::os::raw::c_int,
    pub ShouldClose: bool,
    pub SupportsSeeking: bool,
    pub EC: std_error_code,
    pub pos: u64,
}
#[test]
fn bindgen_test_layout_llvm_raw_fd_ostream() {
    assert_eq!(
        ::std::mem::size_of::<llvm_raw_fd_ostream>(),
        88usize,
        concat!("Size of: ", stringify!(llvm_raw_fd_ostream))
    );
    assert_eq!(
        ::std::mem::align_of::<llvm_raw_fd_ostream>(),
        8usize,
        concat!("Alignment of ", stringify!(llvm_raw_fd_ostream))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_fd_ostream>())).FD as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(FD)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_fd_ostream>())).ShouldClose as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(ShouldClose)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<llvm_raw_fd_ostream>())).SupportsSeeking as *const _ as usize
        },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(SupportsSeeking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_fd_ostream>())).EC as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(EC)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<llvm_raw_fd_ostream>())).pos as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(llvm_raw_fd_ostream),
            "::",
            stringify!(pos)
        )
    );
}
extern "C" {
    #[doc = " Manually flush the stream and close the file. Note that this does not call"]
    #[doc = " fsync."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostream5closeEv"]
    pub fn llvm_raw_fd_ostream_close(this: *mut llvm_raw_fd_ostream);
}
extern "C" {
    #[doc = " Flushes the stream and repositions the underlying file descriptor position"]
    #[doc = " to the offset specified from the beginning of the file."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostream4seekEm"]
    pub fn llvm_raw_fd_ostream_seek(this: *mut llvm_raw_fd_ostream, off: u64) -> u64;
}
extern "C" {
    #[doc = " Open the specified file for writing. If an error occurs, information"]
    #[doc = " about the error is put into EC, and the stream should be immediately"]
    #[doc = " destroyed;"]
    #[doc = " \\p Flags allows optional flags to control how the file will be opened."]
    #[doc = ""]
    #[doc = " As a special case, if Filename is \"-\", then the stream will use"]
    #[doc = " STDOUT_FILENO instead of opening a file. This will not close the stdout"]
    #[doc = " descriptor."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_code"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs19CreationDispositionE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream1(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs10FileAccessE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream2(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Access: llvm_sys_fs_FileAccess,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs9OpenFlagsE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream3(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Flags: llvm_sys_fs_OpenFlags,
    );
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1ENS_9StringRefERSt10error_codeNS_3sys2fs19CreationDispositionENS5_10FileAccessENS5_9OpenFlagsE"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream4(
        this: *mut llvm_raw_fd_ostream,
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
        Access: llvm_sys_fs_FileAccess,
        Flags: llvm_sys_fs_OpenFlags,
    );
}
extern "C" {
    #[doc = " FD is the file descriptor that this writes to.  If ShouldClose is true,"]
    #[doc = " this closes the file when the stream is destroyed. If FD is for stdout or"]
    #[doc = " stderr, it will not be closed."]
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamC1Eibb"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream5(
        this: *mut llvm_raw_fd_ostream,
        fd: ::std::os::raw::c_int,
        shouldClose: bool,
        unbuffered: bool,
    );
}
impl llvm_raw_fd_ostream {
    #[inline]
    pub unsafe fn close(&mut self) {
        llvm_raw_fd_ostream_close(self)
    }
    #[inline]
    pub unsafe fn seek(&mut self, off: u64) -> u64 {
        llvm_raw_fd_ostream_seek(self, off)
    }
    #[inline]
    pub unsafe fn new(Filename: llvm_StringRef, EC: *mut std_error_code) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream(__bindgen_tmp.as_mut_ptr(), Filename, EC);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new1(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream1(__bindgen_tmp.as_mut_ptr(), Filename, EC, Disp);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new2(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Access: llvm_sys_fs_FileAccess,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream2(__bindgen_tmp.as_mut_ptr(), Filename, EC, Access);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new3(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Flags: llvm_sys_fs_OpenFlags,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream3(__bindgen_tmp.as_mut_ptr(), Filename, EC, Flags);
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new4(
        Filename: llvm_StringRef,
        EC: *mut std_error_code,
        Disp: llvm_sys_fs_CreationDisposition,
        Access: llvm_sys_fs_FileAccess,
        Flags: llvm_sys_fs_OpenFlags,
    ) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream4(
            __bindgen_tmp.as_mut_ptr(),
            Filename,
            EC,
            Disp,
            Access,
            Flags,
        );
        __bindgen_tmp.assume_init()
    }
    #[inline]
    pub unsafe fn new5(fd: ::std::os::raw::c_int, shouldClose: bool, unbuffered: bool) -> Self {
        let mut __bindgen_tmp = ::std::mem::MaybeUninit::uninit();
        llvm_raw_fd_ostream_raw_fd_ostream5(
            __bindgen_tmp.as_mut_ptr(),
            fd,
            shouldClose,
            unbuffered,
        );
        __bindgen_tmp.assume_init()
    }
}
extern "C" {
    #[link_name = "\u{1}_ZN4llvm14raw_fd_ostreamD1Ev"]
    pub fn llvm_raw_fd_ostream_raw_fd_ostream_destructor(this: *mut llvm_raw_fd_ostream);
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14raw_fd_ostream12is_displayedEv"]
    pub fn llvm_raw_fd_ostream_is_displayed(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZNK4llvm14raw_fd_ostream10has_colorsEv"]
    pub fn llvm_raw_fd_ostream_has_colors(this: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    #[doc = " This returns a reference to a raw_fd_ostream for standard output. Use it"]
    #[doc = " like: outs() << \"foo\" << \"bar\";"]
    #[link_name = "\u{1}_ZN4llvm4outsEv"]
    pub fn llvm_outs() -> *mut llvm_raw_fd_ostream;
}
extern "C" {
    #[doc = " This returns a reference to a raw_ostream for standard error."]
    #[doc = " Use it like: errs() << \"foo\" << \"bar\";"]
    #[doc = " By default, the stream is tied to stdout to ensure stdout is flushed before"]
    #[doc = " stderr is written, to ensure the error messages are written in their"]
    #[doc = " expected place."]
    #[link_name = "\u{1}_ZN4llvm4errsEv"]
    pub fn llvm_errs() -> *mut llvm_raw_fd_ostream;
}
extern "C" {
    #[doc = " This returns a reference to a raw_ostream which simply discards output."]
    #[link_name = "\u{1}_ZN4llvm5nullsEv"]
    pub fn llvm_nulls() -> *mut llvm_raw_ostream;
}
extern "C" {
    #[link_name = "\u{1}_ZN3lld4coff4linkEN4llvm8ArrayRefIPKcEEbRNS1_11raw_ostreamES7_"]
    pub fn lld_coff_link(
        args: llvm_ArrayRef<*const ::std::os::raw::c_char>,
        canExitEarly: bool,
        stdoutOS: *mut llvm_raw_ostream,
        stderrOS: *mut llvm_raw_ostream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3lld5mingw4linkEN4llvm8ArrayRefIPKcEEbRNS1_11raw_ostreamES7_"]
    pub fn lld_mingw_link(
        args: llvm_ArrayRef<*const ::std::os::raw::c_char>,
        canExitEarly: bool,
        stdoutOS: *mut llvm_raw_ostream,
        stderrOS: *mut llvm_raw_ostream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3lld3elf4linkEN4llvm8ArrayRefIPKcEEbRNS1_11raw_ostreamES7_"]
    pub fn lld_elf_link(
        args: llvm_ArrayRef<*const ::std::os::raw::c_char>,
        canExitEarly: bool,
        stdoutOS: *mut llvm_raw_ostream,
        stderrOS: *mut llvm_raw_ostream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3lld6mach_o4linkEN4llvm8ArrayRefIPKcEEbRNS1_11raw_ostreamES7_"]
    pub fn lld_mach_o_link(
        args: llvm_ArrayRef<*const ::std::os::raw::c_char>,
        canExitEarly: bool,
        stdoutOS: *mut llvm_raw_ostream,
        stderrOS: *mut llvm_raw_ostream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3lld5macho4linkEN4llvm8ArrayRefIPKcEEbRNS1_11raw_ostreamES7_"]
    pub fn lld_macho_link(
        args: llvm_ArrayRef<*const ::std::os::raw::c_char>,
        canExitEarly: bool,
        stdoutOS: *mut llvm_raw_ostream,
        stderrOS: *mut llvm_raw_ostream,
    ) -> bool;
}
extern "C" {
    #[link_name = "\u{1}_ZN3lld4wasm4linkEN4llvm8ArrayRefIPKcEEbRNS1_11raw_ostreamES7_"]
    pub fn lld_wasm_link(
        args: llvm_ArrayRef<*const ::std::os::raw::c_char>,
        canExitEarly: bool,
        stdoutOS: *mut llvm_raw_ostream,
        stderrOS: *mut llvm_raw_ostream,
    ) -> bool;
}
#[test]
fn __bindgen_test_layout_std_basic_string_open0_char_std_char_traits_open1_char_close1_std_allocator_open1_char_close1_close0_instantiation(
) {
    assert_eq!(
        ::std::mem::size_of::<std_basic_string<::std::os::raw::c_char>>(),
        32usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_basic_string<::std::os::raw::c_char>>(),
        8usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_basic_string<::std::os::raw::c_char>)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_char_traits_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_char_traits>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_char_traits)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_char_traits>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_char_traits)
        )
    );
}
#[test]
fn __bindgen_test_layout_std_allocator_open0_char_close0_instantiation() {
    assert_eq!(
        ::std::mem::size_of::<std_allocator>(),
        1usize,
        concat!(
            "Size of template specialization: ",
            stringify!(std_allocator)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<std_allocator>(),
        1usize,
        concat!(
            "Alignment of template specialization: ",
            stringify!(std_allocator)
        )
    );
}
